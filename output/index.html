<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link rel="stylesheet" href="../layout/coderay.css" type="text/css" media="screen" />
</head>
<front></front>
<contents>#contents</contents>
<body><h1> Ruby on Rails 2.1 - O que tem de novo?</h1>

<h1> ActiveRecord</h1>

<h1> ActiveSupport</h1>

<h1> ActiveResource</h1>

<h1> ActionPack</h1>

<h2> TimeZone</h2>

<p>### Definindo um fuso-horário padrão</p>

<p>Uma nova opção foi acrescentada ao método <em>time<em>zone</em>select</em>, agora você pode indicar um valor padrão para os casos em que o seu usuário ainda não tenha selecionado nenhum <em>TimeZone</em>, ou quando a coluna no banco de dados for nula. Para isto foi criada a opção :<em>default</em>, então você poderá usar o método das seguintes maneiras:</p>

<p>ruby. ActionPack/timezone.rb#default</p>

<p>Nos casos onde usamos a opção :<em>default</em> deve aparecer com o <em>TimeZone</em> informado já selecionado.</p>

<h2> Auto Link</h2>

<p>Para quem não conhece, o método <em>auto_link</em> recebe um texto qualquer como parâmetro e se o texto tiver algum endereço de email ou de um site ele retorna o mesmo texto com hyperlinks.</p>

<p>Por exemplo:</p>

<p>ruby. ActionPack/auto_link.rb#exemplo1</p>

<p>Acontece que alguns sites como o Amazon estão usando também o sinal de "=" (igual) em suas URLs, e este método não reconhece este sinal. Veja como o método se comporta neste caso:</p>

<p>ruby. ActionPack/auto_link.rb#exemplo2</p>

<p>Note que o método terminou o hyperlink exatamente antes do sinal de "=", pois ele não suporta este sinal. Quer dizer, não suportava. Nesta nova versão do Rails já temos este problema resolvido.</p>

<h2> Rótulos</h2>

<p>Ao criar um novo formulário usando <strong>scaffold</strong> ele será criado com o seguinte código:</p>

<pre><code>&lt;% form_for(@post) do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :title %&gt;&lt;br /&gt;
    &lt;%= f.text_field :title %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :body %&gt;&lt;br /&gt;
    &lt;%= f.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit "Update" %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>Desta forma faz muito mais sentido. O método <em>label</em> foi incluído. Este método retorna uma <em>string</em> com o título da coluna dentro de uma tag HTML <em><label></em>.</p>

<pre><code>&gt;&gt; f.label :title
=&gt; &lt;label for="post_title"&gt;Title&lt;/label&gt;

&gt;&gt; f.label :title, "A short title"
=&gt; &lt;label for="post_title"&gt;A short title&lt;/label&gt;

&gt;&gt; label :title, "A short title", :class =&gt; "title_label"
=&gt; &lt;label for="post_title" class="title_label"&gt;A short title&lt;/label&gt;
</code></pre>

<p>Percebeu o parâmetro <em>for</em> dentro da tag? O "post<em>title" é o nome da caixa de texto que contém o título do nosso post. A tag <em><label></em> é na verdade um rótulo associado ao objeto *post</em>title*. Quando se clica no rótulo (ele não é um link) o controle associado à ele recebe o foco.</p>

<p>Robby Russell escreveu um artigo interessante em seu blog sobre este assunto. Você pode lê-lo no endereço: <a href="http://www.robbyonrails.com/articles/2007/12/02/that-checkbox-needs-a-label">http://www.robbyonrails.com/articles/2007/12/02/that-checkbox-needs-a-label</a></p>

<p>Também foi incluído o método <em>label_tag</em> no <em>FormTagHelper</em>. Este método funciona exatamente como o label mas de uma forma mais simplista:</p>

<pre><code>&gt;&gt; label_tag 'nome'
=&gt; &lt;label for="nome"&gt;Nome&lt;/label&gt; 

&gt;&gt; label_tag 'nome', 'Seu nome'
=&gt; &lt;label for="nome"&gt;Seu Name&lt;/label&gt; 

&gt;&gt; label_tag 'nome', nil, :class =&gt; 'small_label'
=&gt; &lt;label for="nome" class="small_label"&gt;Nome&lt;/label&gt;
</code></pre>

<h2> Uma nova forma de usar partials</h2>

<p>Algo muito normal no desenvolvimento de softwares em Rails é o uso de partials para evitar a repetição de código. Vejamos um exemplo de seu uso:</p>

<pre><code>&lt;% form_for :user, :url =&gt; users_path do %&gt;
    &lt;%= render :partial =&gt; 'form' %&gt;
    &lt;%= submit_tag 'Create' %&gt;
&lt;% end %&gt;
</code></pre>

<p>Partial é um fragmento de código (um template). A vantagem de se usar uma partial é evitar a repetição desnecessária de código. Para usar uma partial é muito simples, você pode começar com algo mais ou menos assim: <em>render :partial => “name”</em>. Depois deve criar um arquivo com o mesmo nome da partial, mas com um underscore na frente, só isso.</p>

<p>O código acima é a forma como estamos acostumados a fazer hoje, mas nesta nova versão do Rails, faremos a mesma coisa de uma forma um pouco diferente, assim:</p>

<pre><code>&lt;% form_for(@user) do |f| %&gt;
    &lt;%= render :partial =&gt; f %&gt;
    &lt;%= submit_tag 'Create' %&gt;
&lt;% end %&gt;
</code></pre>

<p>Neste exemplo nós vamos renderizar a partial “users/_form”, que receberá uma variável chamada form com as referências criadas pelo <em>FormBuilder</em>.</p>

<p>A forma antiga também vai continuar funcionando.</p>

<h2> Novos namespaces no Atom Feed</h2>

<p>Conhece o método <em>atom_feed</em>? Ele é uma novidade no Rails 2.0, que facilitou muito a criação de feeds Atom. Veja um exemplo de uso:</p>

<p>Em um arquivo <em>index.atom.builder</em>:</p>

<pre><code>atom_feed do |feed|
  feed.title("Nome do Jogo")
  feed.updated((@posts.first.created_at))

  for post in @posts
    feed.entry(post) do |entry|
      entry.title(post.title)
      entry.content(post.body, :type =&gt; 'html')

      entry.author do |author|
        author.name("Carlos Brando")
      end
    end
  end
end
</code></pre>

<p>O que é um atom feed? Atom é o nome de um estilo baseado em XML e meta data. Em outras palavras é um protocolo quer serve para publicar conteúdo na internet que é sempre atualizado, como um blog, por exemplo. Os feeds sempre são publicados em XML e no caso do Atom Feed ele é identificado como application/atom+xml media type.</p>

<p>Nas primeiras versões do Rails 2.0 este método aceitava como parâmetros as opções <em>:language</em>, <em>:root_url</em> e <em>:url</em>, você pode obter mais informações sobre estes métodos na documentação do Rails. Mas com a alteração realizada, agora podemos incluir novos namespaces ao elemento root do feed. Por exemplo, se fizermos assim:</p>

<pre><code>atom_feed('xmlns:app' =&gt; 'http://www.w3.org/2007/app') do |feed|
</code></pre>

<p>Ele retornará isto:</p>

<pre><code>&lt;feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom" xmlns:app="http://www.w3.org/2007/app"&gt;
</code></pre>

<p>Adaptando o exemplo anterior, poderíamos usá-lo assim:</p>

<pre><code>atom_feed({'xmlns:app' =&gt; 'http://www.w3.org/2007/app',
           'xmlns:openSearch' =&gt; 'http://a9.com/-/spec/opensearch/1.1/'}) do |feed| 

  feed.title("Nome do Jogo")
  feed.updated((@posts.first.created_at))
  feed.tag!(openSearch:totalResults, 10) 

  for post in @posts
    feed.entry(post) do |entry|
      entry.title(post.title)
      entry.content(post.body, :type =&gt; 'html')
      entry.tag!('app:edited', Time.now) 

      entry.author do |author|
        author.name("Carlos Brando")
      end
    end
  end
end
</code></pre>

<h2> Cache</h2>

<p>Todos os métodos <em>fragment<em>cache</em>key</em> agora retornam por padrão o namespace 'view/' como prefixo.</p>

<p>Todos os caching stores foram retirados de <em>ActionController::Caching::Fragments::** e agora estão em </em>ActiveSupport::Cache::<em>*. Neste caso se você faz referência a um store, como </em>ActionController::Caching::Fragments::MemoryStore<em>, por exemplo, será necessário alterar sua referência para </em>ActiveSupport::Cache::MemoryStore*.</p>

<p><em>ActionController::Base.fragment<em>cache</em>store</em> deixa de existir e dá lugar à <em>ActionController::Base.cache_store</em>.</p>

<p>Foi incluído no <em>ActiveRecord::Base</em> o método <em>cache_key</em> para facilitar o armazenamento em cache de Active Records pelas novas bibliotecas *ActiveSupport::Cache::**. Este método funciona assim:</p>

<pre><code>&gt;&gt; Product.new.cache_key
=&gt; "products/new"

&gt;&gt; Product.find(5).cache_key
=&gt; "products/5"

&gt;&gt; Person.find(5).cache_key
=&gt; "people/5-20071224150000"
</code></pre>

<p>Foi incluído o <em>ActiveSupport::Gzip.decompress/compress</em> para facilitar o wrapper para o <strong>Zlib</strong>.</p>

<p>Agora você pode usar entre as opções de environment o <em>config.cache_store</em> para informar o local padrão de armazenamento do cache. Vale lembrar que se o diretório <em>tmp/cache</em> existir o padrão é o <em>FileStore</em>, caso contrário o <em>MemoryStore</em> é usado. Você pode configurar das seguintes formas:</p>

<pre><code>config.cache_store = :memory_store
config.cache_store = :file_store, "/path/to/cache/directory"
config.cache_store = :drb_store, "druby://localhost:9192"
config.cache_store = :mem_cache_store, "localhost"
config.cache_store = MyOwnStore.new("parameter")
</code></pre>

<p>Para facilitar as coisas, foi incluído o comentário abaixo no arquivo <em>environments/production.rb</em>, afim de lembrá-lo desta opção.</p>

<pre><code># Use a different cache store in production
# config.cache_store = :mem_cache_store
</code></pre>

<h1> Railties</h1>

<h1> Rake Tasks</h1>

<h1> Ruby 1.9</h1>

<h2> Detalhes</h2>

<p>O principal foco das alterações do Rails foi o Ruby 1.9, mesmo os menores detalhes foram analisados para deixar o Rails o mais compatível possível com a nova versão do Ruby. Detalhes como alterar de <em>File.exists?</em> para <em>File.exist?</em> não foram deixados de fora.</p>

<p>Também, no Ruby 1.9, o módulo <em>Base64</em> (base64.rb) foi removido, por isto todas as referencias a ele foram substituídas por <em>ActiveSupport::Base64</em>.</p>

<h2> Novos métodos para a classe DateTime</h2>

<p>Outra alteração interessante para a nova versão. Para manter a compatibilidade (duck-typing) com a classe <em>Time</em>, três métodos novos foram adicionados à classe <em>DateTime</em>. Os métodos são <em>#utc</em>, <em>#utc?</em> e <em>#utc_offset</em>. Vamos ver um exemplo de uso de cada um:</p>

<pre><code>&gt;&gt; date = DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))
#=&gt; Mon, 21 Feb 2005 10:11:12 -0600

&gt;&gt; date.utc
#=&gt; Mon, 21 Feb 2005 16:11:12 +0000

&gt;&gt; DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc?
#=&gt; false

&gt;&gt; DateTime.civil(2005, 2, 21, 10, 11, 12, 0).utc?
#=&gt; true

&gt;&gt; DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc_offset
#=&gt; -21600
</code></pre>

<h1> Prototype e script.aculo.us</h1>

<h2> Atualizações</h2>

<p>O Rails passa a usar a partir de agora a versão 1.6.0.1 do Prototype. Isto serve como um preparatório para a versão 1.8.1 do script.aculo.us.</p>

<h1> Debug</h1>

<h2> Ruby-debug nativo</h2>

<p>Foi habilitada novamente a opção de usar o <strong>ruby-debug</strong> nos testes do Rails.</p>

<p>Se antes você desejasse usá-lo nos testes seria necessário incluir um <em>require 'ruby-debug'</em> na classe e logo em seguida usar o método <em>debugger</em> no local desejado. Agora só se preocupe com o método <em>debugger</em>, o resto é nativo, desde que você já tenha o gem instalado.</p>

<h1> Bugs e Correções</h1>

<h2> Adicionar colunas no PostgreSQL</h2>

<p>Havia um bug ao se usar o banco de dados <strong>PostgreSQL</strong>. O bug ocorria quando se criava uma migration para adicionar uma coluna em uma tabela já existente, veja um exemplo:</p>

<p>Arquivo: <em>db/migrate/002<em>add</em>cost.rb</em></p>

<pre><code>class AddCost &lt; ActiveRecord::Migration
  def self.up
    add_column :items, :cost, :decimal, :precision =&gt; 6, 
   :scale =&gt; 2
  end

  def self.down
    remove_column :items, :cost
  end
end
</code></pre>

<p>Note que estou criando uma coluna com <em>:precision => 6</em> e <em>:scale => 2</em>. Agora é hora de rodar o <em>rake db:migrate</em> e vamos ver como ficou nossa tabela no banco:</p>

<table border="0" cellspacing="5" cellpadding="5">
    <tr>
        <th>Column</th>
        <th>Type</th>
        <th>Modifiers</th>
    </tr>
    <tr>
        <td>id</td>
        <td>integer</td>
        <td>not null</td>
    </tr>
    <tr>
        <td>descr</td>
        <td>character varying(255)</td>
        <td></td>
    </tr>
    <tr>
        <td>price</td>
        <td>numeric(5,2)</td>
        <td></td>
    </tr>
    <tr>
        <td>cost</td>
        <td>numeric</td>
        <td></td>
    </tr>
</table>


<p>Veja a coluna "cost" que acabamos de criar. Ela é um <em>numeric</em> comum, mas deveria ser uma coluna como a "price", logo acima dela, mais precisamente um <em>numeric(6,2)</em>. Nesta versão este erro não existe mais, a coluna será criada da forma correta neste banco de dados.</p>

<h1> Informações Adicionais</h1>

<h2> Protegendo-se de Cross Site Scripting</h2>

<p>No Rails 2.0 o arquivo application.rb ficou desta maneira:</p>

<pre><code>class ApplicationController &lt; ActionController::Base
  helper :all

  protect_from_forgery
end
</code></pre>

<p>Note a chamada para o método <em>protect<em>from</em>forgery</em>.</p>

<p>Já ouviu falar de Cross Site Scripting? Este é o nome de uma falha de segurança encontrada facilmente em grande parte dos websites e aplicações web que permite à pessoas maldosas (aqui estou me referindo à adolescentes sem nada para fazer e sem vida social) alterarem o conteúdo de páginas web, incluírem conteúdo hostil, executarem ataques de phishing, obterem o controle do navegador através de códigos JavaScript e na maioria dos casos forçarem o usuário a executar algum comando que eles desejem. Este último tipo de ataque se chama cross­site request forgeries.</p>

<p>O Cross Site Request Forgeries é um tipo de ataque que consiste em obrigar usuários legítimos a executarem uma série de comandos sem nem mesmo saberem disto. E agora com o aumento do uso de Ajax, a coisa tem ficado ainda pior.</p>

<p>Na verdade, este método serve para nos assegurar de que todos os formulários que sua aplicação está recebendo estão vindo dela mesma, e não de um link perdido de algum outro site. Ele consegue isto incluindo um token baseado na sessão em todos os formulários e requisições Ajax geradas pelo Rails, e depois verifica a autenticidade deste token no controller.</p>

<p>Lembre-se que requisições via GET não são protegidas. Mas isto não será um problema se somente à usarmos para nos trazer dados, e nunca para alterar ou gravar algo em nosso banco de dados.</p>

<p>Se quiser aprender mais sobre CSRF(Cross-Site Request Forgery) use os endereços abaixo:</p>

<ul>
<li><p><a href="http://www.nomedojogo.com/2008/01/14/como-um-garoto-chamado-samy-pode-derrubar-seu-site/isc.sans.org/diary.html?storyid=1750">http://www.nomedojogo.com/2008/01/14/como-um-garoto-chamado-samy-pode-derrubar-seu-site/isc.sans.org/diary.html?storyid=1750</a></p></li>
<li><p><a href="http://www.nomedojogo.com/2008/01/14/como-um-garoto-chamado-samy-pode-derrubar-seu-site/isc.sans.org/diary.html?storyid=1750">http://www.nomedojogo.com/2008/01/14/como-um-garoto-chamado-samy-pode-derrubar-seu-site/isc.sans.org/diary.html?storyid=1750</a></p></li>
</ul>


<p>Mas lembre-se que isto não é uma solução definitiva para nosso problema, ou como costumamos dizer, não é uma bala de prata.</p>
</body>
</html>
